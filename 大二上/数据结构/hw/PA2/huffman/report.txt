# 解题报告

陈英发 2018080073 计82
2019-11-21
-----------

## 思路

    没有什么特别，直接 huffman，但是一开始我打算从上往下，逐个节点
添加，然后找到一个规律（而且是贪婪规律，这样对于每一字符都可以在h
时间内完成插入，这样就会使最多O(n)，其中n是字符的个数。尝试了一会儿
后才发现代码错漏百出，主要是想不到一个插入算法。
    然后就搜了一下网上，才发从下往上，合并节点的方法。，然后就AC了。
这个复杂度很明显，因为每次合并，都会减少一个待处理的节点，所以构建树
的时间复杂度是O(n)，但是输出编发方案时，对于每一个节点都要各自查找
从根点的他们的路径，所以时间复杂度是O(n^2)，空间复杂度就是O(n)因为
每个字符要一个节点，而堆中也要能存储所有字符。

## 实现

    从下往上的构造树的方法很简单，而且此题数据量很小，所以其实根本
完全不用考虑时间和空间复杂度。
    我主要就是先给每一个小写字母构造一个叶子节点，放进一个长度为26
的数组。然后有一个堆，堆中保持从下往上的下降排序（因为量小，所以蛮
力即可，然后我是用数组来实现这个堆），然后逐次对堆中最上面两个节点
合并再从新放进堆里，直到堆中仅剩下一个节点，就是 huffman 树的根节点
。最后要注意当只有一个字符的时候，这样构造树是不对的，因为字符对应
的节点不可以是根节点，因为这样等同于编码长度为0，并不是一个有效的
编码。
   
## debug

    真的很简单，所以很少 bug，基本上只是：我一开始忘了重新插入堆中，
而直接放回堆顶。改了就AC。

## 参考文献：

https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/
