# 解题报告

陈英发 2018080073 计82
2019-11-20
---------
## 思路 1

​    直接用老师在课上讲解的找双连通图的算法，但是发现并不能直接用，得做出一些修改。主要问题是，我不太清楚怎么修改算法以得到两个节点之间的必经点。
​    实现完讲义中的 bcc (tarjan)  后，我就想到可以利用桥来查找必经点。首先通过 tarjan 得到所有桥，然后用 bfs 得到两个点之间任意一条路径，可知此路径中的桥是由两点间的必经点构成。而且此路径必定包含所有所求的必经点。

## 实现 1

​    基础不扎实的我虽然能用言语解释算法，但是还是对实际的实现模糊不清，使我写出来的代码很多bug。花了非常长时间才debug好，却发现TLE...
​    原来我根本没有想清楚上述算法的时间复杂度。我还以为因为bfs，tarjan 和 mergesort 的时间复杂度分别是O(n)，O(n+m)，O(nlogn)，故得 O(nlogn+m)，但是因为我在bfs中要记录每个节点
从开始到路径，所以对于每个节点都要复制之前的路径，这样的复杂度是，O(n^2)的。。。

## 思路 2

​    然后我就发觉q非常小，根本不用进行缩点，只需要对于每个查询都重新运行一整次tarjan都应该能通过的。然后想了挺久（网上找了很久也找不到针对这个问题的办法）才灵光一闪，如雷灌顶，想到怎么找到两点间的必经点（主要是我太菜，想了很久，浪费了很多时间）。
​    这个思路就是从两点之一（设为a）作为dfs树的根，另外一点设为b。设lastBcc为b，当我找到包含b的双连通图，我就pop回到此子图的割点，并将lastBcc设为该割点，重复此操作即可。
    这样很明显就是O((n+m)*q)的时间复杂度，因为根本就是重复tarjan q次，如果q大一些就肯定不让人满意的，但是当q=10时，是肯定足够的。

## 实现 2

​    这一次很快，bug也不是很多，主要是通过之前两天的debug我已经对tarjan很熟悉吧。。。而且不需要对之前的代码做出很多修改。

## debug

​    对于上述第一个思路，我主要出现的 bug 是 MLE （其实还有很多不明来历，来无踪去无影的bug，我注释掉不同的代码得到完全不一样的错误），然后其实我到最后还是不清楚为什么报这样的错误，因为是肯定没有使用大于256MB的空间。最后我将路径复制的代码改成class State中的一个函数 copyPath() 就没有 MLE 了。但是就编程了 TLE，这时候才发现原来算法本身的时间复杂度是太大。。。

## 参考文献

https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/
https://www.geeksforgeeks.org/biconnected-components/
https://www.cnblogs.com/Parsnip/p/10388819.html
教材