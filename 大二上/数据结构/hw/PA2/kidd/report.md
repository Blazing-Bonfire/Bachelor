# 解题报告

陈英发  计82  2018080073

2019-11-15

---

## 思路

​	我是听完助教讲解 PA 后才开始的，所以一开始已经知道是要用线段树。

## 实现

​	为了训练自己，尝试了只看课堂讲义来实现线段树，而且修改到用来解答 PA-Kidd，很可惜，大概一个小时候我放弃了，所以开始上网。

​	我发觉我很难实现出来的原因是讲义中的线段树是单点查询，但是题目要求区间查询。然后我发觉助教的PPT也说道这一点，但是我不是很看懂助教的PPT。后来我花了非常多时间来思考这个问题，有点不是很想百度，但是最后还是百度了。然后才发觉原来人家都是用 “懒惰标记” 这个方法来实现。但是助教当时在课上明明说，不用也可以，所以我一直没有直接百度懒惰标记。最后看了看，不用对讲义的线段树做出很多修改就可以实现懒惰标记。

## 调试

​	编程方面比较顺利，没有特别多bug，主要花了大部分时间在思考上面，基本上都是在纸上画数据结构和特例。最后懒惰标记的实现也是很快解决。但是我第一次90%测试的最后两个点WA，想了一想，我有两个猜测：

1. 虽然n小于2^31，但是如果加一就超出int的数值范围。

2. 懒惰标记的数值我使用int lazy[]，但是代码中有代码如下：
   

   ```c++
   nodes[2*k]->cnt += nodes[2*k]->len() * lazy[k]; 
   ```

   边的rvalue的两项都是int类型，可能复制到左边前已经超出int数值范围从而出现错误值，所以左边有可能得到错误数值。

​    反正我看到空间复杂度不是很紧，我把差不多所有int改成long long int就通过了。

## 参考：

教材

助教PPT和讲解

https://blog.csdn.net/zhhe0101/article/details/53871453
https://www.geeksforgeeks.org/interval-tree/