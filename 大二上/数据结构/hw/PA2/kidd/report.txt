# 解题报告

陈英发  计82  2018080073
2019-11-15
-----------------
## 思路

​    我是听完助教讲解 PA 后才开始的，所以一开始已经知道是要用线段树。但是我看了讲义还是不是很会实现出来。为了训练自己，尝试了只看课堂讲义来实现线段树，而且修改到用来解答 PA-Kidd，很可惜，大概一个小时候我放弃了，所以开始上网。
​    
    我发觉我很难实现出来的原因是讲义中的线段树是单点查询，但是题目要求区间查询。然后我发觉助教的PPT也说道这一点，但是我不是很看懂助教的PPT。后来我花了非常多时间来思考这个问题，然后才发觉原来人家都是用 "懒惰标记" 这个方法来实现。但是助教当时在课上明明说，不用也可以，所以我一直没有直接百度懒惰标记。最后看了看，不用对讲义的线段树做出很多修改就可以实现懒惰标记。

    看了网上关于懒惰标记笔记，csdn社区的人群的讲解算法能力真的让人头疼。我觉得真的不如不写，然后的确很多人往往就是直接贴代码，还不是自己的代码，是直接复制过来的。算了，看了一会儿还是能懂的，基本上就是每次更新节点中的翻转次数，先存起来，然后下一次要经过这个节点的一半时（即之后的第一次会访问这个节点的子树中的节点）就将这些翻转次数往下推。

    时间复杂度：每个操作有两个坐标，所以最多能有2*m+1个线段，所以线段树的高度是O(logm)，因此对于每次查询或者更新都需要O(logm)，所以总共的时间复杂度是O(m*logm)。注：与n完全无关。
    空间复杂度：从算法中可以看到，所有数组要么就是m，要么就是two，其中two最大可以是4m，所以空间复杂度是O(m)。

## 实现

    我上网的时候看到有人用一维数组来存储二叉树，我之前没有碰过这样的概念，所以就打算练习练习就用了那样的数据结构，很容知道是会省空间的。操作起来也挺方便的。因为线段树需要所有叶子在同一层，所以这个数组的长度应该是大于2*m的最小的2的指数。
    我首先存储所有输入，将线段的分割点按升序排序，然后每两个数构成一个基本线段的左右两端的坐标，然后将这些设为线段树的叶子，如果不够填满，就将一个长度为零的线段构造节点来填充。然后从下往上（在数组中就是从有王座）合并没两个节点成为上一层的一个节点，反复操作知道最顶层，就是根点。然后就是对线段树的一般操作，这里添加了一个 "懒惰标记" 而已。但是都是经典算法。所以我很简陋地解释一下而已。基本上就是，当我要对某线段 A=[a, b]进行一个操作op()，我就从跟开始遍历，如果目前考虑的节点是完全被A包含，则对A执行op()并添加懒惰标记，如果完全不重叠，那就return，如果重叠但不完全包含，则将懒惰标记往下推，并且遍历目前考虑节点的两个子节点。

## 调试

​    编程方面比较顺利，没有特别多bug，主要花了大部分时间在思考上面，基本上都是在纸上画数据结构和特例。最后懒惰标记的实现也是很快解决。但是我第一次90%测试的最后两个点WA，想了一想，我有两个猜测：

1. 虽然n小于2^31，但是如果加一就超出int的数值范围。

2. 懒惰标记的数值我使用int lazy[]，但是代码中有代码如下：
   
   nodes[2*k]->cnt += nodes[2*k]->len() * lazy[k]; 

    右边的rvalue的两项都是int类型，可能复制到左边前已经超出int数值范围从而出现错误值，所以左边有可能得到错误数值。

​    反正我看到空间复杂度不是很紧，我把差不多所有int改成long long int就通过了。

---------------
## 参考：

教材
助教PPT和讲解
https://blog.csdn.net/zhhe0101/article/details/53871453
https://www.geeksforgeeks.org/interval-tree/