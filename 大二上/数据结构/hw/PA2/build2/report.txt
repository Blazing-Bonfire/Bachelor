# 解题报告

陈英发 2018080073 计82

19-11-22

## 前言

​    这个是我最早尝试的题，但是是花我最长时间的一题，我到现在都不太清楚我大多数的bug具体是什么导致的，很多时候，我只是去改写一些我个人觉得比较不稳定或者比较复杂、晦涩的代码，然后bug要么就消失，要么就变成别的错误。在debug段里更深入的写。

## 思路

​    这一题其实原理没有什么特别，是很正常的一个多叉树（虽然也可以用二叉树结构来表示），移动节点也是很基本的操作，所以除了教材，我根本没有参考任何文献或者资料。唯一比较复杂的就是要维护大小和高度信息，使可以在O(1)时间内完成查询。题中限制给出cost总和不高于 1e6，所以只需要能对于每个移动操作，都在O(cost)时间内完成，就肯定能AC。

​    大小信息的维护很简单，构建树时，遍历一次树，然后给每个节点其当前大小的一个int size。对于每次移动，只需要更新其父节点，其父节点的父节点，。。。这样往上更新。

​	高度信息稍微复杂一些，我是通过跟刘润达小教员答疑而得到启发的。方法就是对于每个节点都维护一个h，其值为此节点高度和其所有弟弟的高度之中的最大值。这样，查询高度是，若是叶结点，返回 0，否则返回其长子的h+1。更新是有点麻烦，因为要更新其所有哥哥的高度，其父亲及其所有哥哥的高度，等等。

## 复杂度估算

​    很容易看到，这样就能O(1)时间内完成大小和高度的查询。构建树的过程需要处理每个节点，对于每个节点都要处理属于它的所有边，但是因为这肯定是一个联通树，所以有n-1个边，所以时间复杂度仍然是O(n)。至于移动节点很明显就是直接跟着输入中给出的路径即可，所以是O(cost)，而更新高度根本就是反向地走同一条路径，所以也是O(cost)，至于更新大小，不用更新哥哥们，所以是小于O(cost)。因此，总复杂度：O(cost + n)。

## 实现

​	我已经提到过，原理真的很简单，除了高度信息的维护，其他我都基本上能直接想到，但是实现起来却一头雾水。可以看到我提交了很多次，其中有好几个版本，然后有一段时间没有提交，那是因为我放弃了，然后最后重新写一遍，在经过一轮debug，就AC了。

​	这一开始想着用二叉树结构，这样维护高度信息我个人认为容易一些，但是多叉树到二叉树的转换有点太麻烦了，所以放弃了。然后就是正常多叉树，其中每个节点的子节点用我个人编写的列表donList来实现，本来是一个我的私人库，但是我黏贴到代码中，省得每次都要压缩两个文件。

​	一开始，我是用指向节点的指针 Node * 作为成员变量来记录一个节点的子节点和父节点，但是在我最后的版本改成了，将所有节点放进一个指向节点的指针的数组 Node** nodes[maxN] ，因为最多只有1e6个节点，所以可以静态声明。然后都不存储指向节点的指针，直接存储该节点的编号，然后用 nodes[编号] 即可。这样还不用在节点中存储自己的编号。

​	对于更新高度和大小我都是用往上的递归，大小的更新非常简明易懂，但是高度就有点难，主要是因为每个节点没有直接其哥哥们的信息，所以我的解决方法这个更新过程都是父亲给其孩子更新h（高度）值。

## debug

​	写了好几个版本，每个版本都是错漏百出，然后不知道bug出出现在哪里。

​	为了找到bug，我用了一个“办法”，就是给代码中注释掉一段，然后提交上去，看看错误有没有改变，有的话，就说明此处有问题。但是这个方法帮不到我，因为我的代码有很多部分备注释掉后错误信息会改变，但是不是变成正确，很多时候连WA都不是，反而是另外的错误信息而已，而且有本来AC变成不通过，而本来错误变成AC。然后因为错误信息是在是太多不同的变化，所以无法规划哪里出错，是按什么样的规律出现什么错误信息。导致我放弃了。。。最后用了我5成测试中最高分的40分来测9成，得到了60分。

​	然后过了好多天后，我回来了，重新写一次代码，然后还是RE（11和6都有，取决于我注释掉什么代码），但是很重要的一点就是这一次的错误信息没怎么大的变化，这一次我看一看我之前提交的无数次，因为我都有给注释我改写了代码的哪个部分，但是还是没用。我知道11和6是空间太大，太小或者访问无效地址的问题，所以突然想到我自己的List中是默认remove后会释放被删除的节点，所以有可能释放了我的Node** nodes数组中的节点，的确，修改了那部分就AC多了一些测试点。最后我在看了一看旧版本的提交的我以前写的注释，发现其中一个是"insert 0 by default"，不是很记得我是指什么，但是就去看看我的insert函数，然后发现我insert后没有将节点的父节点int par设为新的父节点！这个跟我的那个注释没有关系，但是我就是通过它，机缘巧合的撞倒我的bug所在。改了这个bug后，AC！