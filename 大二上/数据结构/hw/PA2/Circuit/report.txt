# 解题报告

陈英发 2018080073 计82
21:30 19-11-12
-------

## 思路

​    直接跟着助教说的方法，用二叉的字典树，然后对每一个数逆其道而行。树的最低，即叶子，就有列表，用来存储对应着那个途径的一个64位板子的编号 [0, n) 。这样对于每一个64位数，都只需要从上往下遍历字典树一次，每一层做一次处理，所以是O(h*n)，其中h是树的高度，也是每个数的长度，这里就是64，因为这里是常数，所以也可以认为是O(n)复杂度。但是写O(h*n)是更准确一些，而且其实开始有点接近时间的上限了。。。空间复杂会在下一段提到。

## 实现

​    我直接存储所有输入到一个 bool[5e5][64] 的一个数组（这里显然用int数组来存储就会超出内存限制），然后循环i从0到n，从字典树删除第i-k-2个板子，插入i+k+1个板子，然后找对于字典树查询第i个板子的64位（逆其道而行）。因为这棵字典树在任何时刻都会有k（或者k+1）个叶子，也就是大概2*k和节点，然后我一开始就存储所有数字到一个数组，这需要h*n个字节，其中h是树的长度（这里是64，是常数，故也可以认为是O(n)），所以空间复杂度是O(n*h+k)。还是有点接近256MB的限制的。。。但是AC了。

## Debug

​    我实现了列表和字典树后，对于样例的输入能得到正确输出，虽然已经知道了空间复杂度有点高，但是直接交了，然后只通过了第7和8个点。
    Debug 了一会儿才发现，原来我是没有成功从字典树的叶子的列表中除掉所有元素后，要删掉到这个叶子的路径（不删掉属于其他叶子的路径）。这个实现后，我就能通过1到8个case，第9和10则有TLE。然后我就要对空间复杂度做出优化。
    算了一算，我目前设计的字典树中每个节点TTNode都有3个成员：
      TTNode* lc, rc;
      List<int> list;
    尝试了很多很微不足道的优化之后才察觉最耗空间的是list并不是指针，因为这样对于每个TTNode还会占一个List中的哨兵以及哨兵的成员的空间。将其改成指针后，然后不需要的时候释放其占有的空间就通过了（90%）。


## 参考材料：

11月8日，课上助教讲解
https://www.cnblogs.com/qixingzhi/p/9425017.html