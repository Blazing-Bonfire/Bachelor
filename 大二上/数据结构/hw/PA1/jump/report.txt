陈英发 Donny Chan
23:45 2019-10-12
-------------------
解题报告 
DSA2019-PA1 Jump

一开始只是想着用动态规划，然后不知道原来页面最底有提示。但是后来我看到提示后，就知道要用Queap，但是虽然我已经做完了Stock，而且使用了Queap，我还是想了非常非常就才想到怎么将Queap利用于此题。原来首先是要将矩阵发过来，意思是，如果设矩阵A中第i列中，[l[i], r[i]]的元素都设为1，其余设为0，然后将A转置。此时，循环A中每一行A[i]时，只需要求从A[i]中的值为1的元素对应的格子跳出的最小用时，最后就可以得到答案。可以留意到，每次需要计算的格子编号小于i、是连续而且是单调增加，现在就很容易用Queap了。
    一些细节：首先因为10e6个格子太大，所以要优化空间复杂度。dp不能用二维，之前提到的矩阵也只能是概念，也不能用二维数组来存储。dp用以为很简单，Queap的dp通常都是一维的，所以不做解释。对于矩阵A的转置，我使用一下方法：
	
int jl = 1, jr = 1;
for (int i = 2; i <= n; i++){
    while (r[jr] < i && jr < n) jr++;
    left = jr;
    while (l[jl] <= i && jl < n) jl++;
    right = jl - 1;

    //以left和right计算...
}

这样就可以达到时间和空间复杂度都是O(n)的算法。
----------------------
